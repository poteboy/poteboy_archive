{"componentChunkName":"component---src-components-post-tsx","path":"/blog/level_order_binary_tree_traversal","result":{"data":{"contentfulTech":{"title":"二分木の幅優先探索をLevel Order Traversalで実現する","publishedDate":"May 4th, 2021","description":"二分木を幅優先探索するレベル順走査アルゴリズムの解説とPythonの実装コード","body":{"childMarkdownRemark":{"html":"<h2>Level order traversalとは</h2>\n<p>二分木が与えられた時に、同じ階層に存在するノードを全て走査してから次の階層を走査するようなアルゴリズムをLevel order traversal(レベル順走査)と言い、二分木に対する幅優先探索アルゴリズムとして知られている。。</p>\n<p>例えば以下のような二分木が与えられたとき、Level order traversalでは<code class=\"language-text\">[[1],[2,3],[4,5,6,7]]</code>という順に走査される。</p>\n<p><a\n          class=\"gatsby-resp-image-link\"\n          href=\"https://images.ctfassets.net/k8nc29mdlquq/59AVf3MUyITQOHCyy25Jfl/056e1b1466f7c07d2d5b7284f1a825e4/____________________________2021-05-05_1.09.17.png\"\n          style=\"display: block\"\n          target=\"_blank\"\n          rel=\"noopener\"\n        >\n          <span\n        class=\"gatsby-resp-image-wrapper\"\n        style=\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\"\n      >\n        <span\n          class=\"gatsby-resp-image-background-image\"\n          style=\"padding-bottom: 76.04355716878402%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,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'); background-size: cover; display: block;\"\n        >\n          <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"二分木\"\n        title=\"\"\n        src=\"https://images.ctfassets.net/k8nc29mdlquq/59AVf3MUyITQOHCyy25Jfl/056e1b1466f7c07d2d5b7284f1a825e4/____________________________2021-05-05_1.09.17.png\"\n        srcset=\"https://images.ctfassets.net/k8nc29mdlquq/59AVf3MUyITQOHCyy25Jfl/056e1b1466f7c07d2d5b7284f1a825e4/____________________________2021-05-05_1.09.17.png?w=276 276w,\nhttps://images.ctfassets.net/k8nc29mdlquq/59AVf3MUyITQOHCyy25Jfl/056e1b1466f7c07d2d5b7284f1a825e4/____________________________2021-05-05_1.09.17.png?w=551 551w,\nhttps://images.ctfassets.net/k8nc29mdlquq/59AVf3MUyITQOHCyy25Jfl/056e1b1466f7c07d2d5b7284f1a825e4/____________________________2021-05-05_1.09.17.png?w=1102 1102w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n        </span>\n      </span>\n        </a></p>\n<br/>\n<p>このような走査を実現するには、キューというFIFOのデータ構造を使うのが一般的であるので、まず初めにキューを使った解法をPythonコードを交えながら解説する。</p>\n<p>なお、再帰関数を用いてもLevel Order Traversalを実現することができる。こちらは厳密には幅優先探索ではなく深さ優先探索になるのだが、こちらの手法でも同じ結果を出力する事ができるので、併せて紹介する。</p>\n<br/>\n<h2>Pythonで二分木を作る</h2>\n<p>アルゴリズムを実装する前に、まずは先ほどの二分木をPythonで実装する。</p>\n<p>ノードの値、そしてleftとrightにポインタを持つノードクラスを定義し、ポインタを後続ノードと繋げれば良い。</p>\n<div class=\"gatsby-code-title your-custom-class-name\">level_order.py</div>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> val\n        self<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n        self<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n\nn1 <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nn2 <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\nn3 <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\nn4 <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\nn5 <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\nn6 <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span>\nn7 <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span>\nn1<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> n2\nn1<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> n3\nn2<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> n4\nn2<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> n5\nn3<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> n6\nn3<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> n7\n</code></pre></div>\n<br/>\n<h2>キューとは</h2>\n<p>キューとは、FIFO(First In First Out)型のデータ構造で、文字通り最初に格納されたデータが最初に取り出される仕組みを持つ。</p>\n<p>キューにデータを格納する事をエンキュー(enqueue)、データを取り出す事をデキュー(dequeue)と言い、Pythonではそれぞれ配列に対して<code class=\"language-text\">append</code>と<code class=\"language-text\">pop</code>で実現できる。</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># enqueue</span>\nqueue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># dequeue</span>\nqueue<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<br/>\n<h2>Level order Traversalの実装</h2>\n<h3>キューを用いた解法</h3>\n<p>level order traversalのアルゴリズムは次のようになる。</p>\n<ol>\n<li>まず初めに、根ノードをキューに格納する。</li>\n<li>キューに格納されている全てのノードの値を空配列に追加する。</li>\n<li>その後、キューに格納されている全てのノードをその子ノードに更新する。子ノードが存在しない場合は何もしない。</li>\n<li>キューが空になるまで上記の処理を繰り返す。</li>\n</ol>\n<p>上で紹介した二分木で言うと、まず初めに１という値が格納された根ノードがキューに格納される。</p>\n<p>次に、キューに入っている全てのノード（現段階では根ノードのみ）の値を答えとなる配列に追加する。現段階で、配列の中身は<code class=\"language-text\">[[1]]</code>。</p>\n<p>その処理が終わった後に、キューに格納される全てのノード（現段階では根ノードのみ）の子ノード、つまり現段階では左の子ノードである２と右の子ノードである３、でキューを更新する。</p>\n<p>この時注意しなければならないのは、根ノードが子を持たない時は<code class=\"language-text\">None</code>がキューに格納されてしまうので、その場合はNoneを削除する必要がある。</p>\n<p>上記の作業をキューの中にノードが存在する限り繰り返し、キューの中身が全てNoneになったら処理は終了する。</p>\n<p>ノードはキューに追加する１回とキューから取り出される１回の計２回の処理が<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>回(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mtext>ノードの数</mtext></mrow><annotation encoding=\"application/x-tex\">N=ノードの数</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">ノードの数</span></span></span></span></span>)行われることになるが、オーダー記法では定数倍は無視されるので、計算量は<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>となる。</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token operator\">**</span><span class=\"token operator\">*</span> 省略 <span class=\"token operator\">**</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">levelOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    ans<span class=\"token punctuation\">,</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        ans<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">for</span> node <span class=\"token keyword\">in</span> queue<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        tmp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">for</span> node <span class=\"token keyword\">in</span> queue<span class=\"token punctuation\">:</span>\n            tmp<span class=\"token punctuation\">.</span>extend<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span>\n        queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>node <span class=\"token keyword\">for</span> node <span class=\"token keyword\">in</span> tmp <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span> ans\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>levelOrder<span class=\"token punctuation\">(</span>n1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<br/>\n<h3>再帰関数を用いた深さ優先的解法</h3>\n<p>まず初めに、空配列<code class=\"language-text\">ans</code>と０を格納した変数<code class=\"language-text\">index</code>を宣言し、<code class=\"language-text\">levelOrder</code>関数の引数として受け取った根ノードと併せて、新たに補助的に作成した関数（ここでは<code class=\"language-text\">helper</code>とする）に代入する。</p>\n<p>ここで宣言した<code class=\"language-text\">ans</code>は最終的な出力にあたり、<code class=\"language-text\">index</code>は関数が実行される時点での木の深さを表す。</p>\n<p>この<code class=\"language-text\">helper</code>関数では、次のようなアルゴリズムを実行する。</p>\n<ol>\n<li>引数として受け取ったノードが<code class=\"language-text\">null</code>である場合は処理を終了する</li>\n<li><code class=\"language-text\">ans</code>の中に格納されている配列の数よりも<code class=\"language-text\">index</code>+1した数の方が大きければ、<code class=\"language-text\">ans</code>にから配列を追加する</li>\n<li><code class=\"language-text\">ans</code>配列の0から数えて添字<code class=\"language-text\">index</code>番目にあたる配列に受け取ったノードの値を追加する。</li>\n<li>受け取ったノードの両方の子ノードに対して同じ処理を繰り返す。</li>\n</ol>\n<p>このアルゴリズムがなぜ深さ優先探索なのかは、上記アルゴリズムの④の部分を見れば分かる。</p>\n<p>上で紹介した二分木を例にとって説明すると、まず<code class=\"language-text\">helper</code>関数が最初に呼び出されてから③に至った段階では、<code class=\"language-text\">ans</code>配列の中身は<code class=\"language-text\">[[1]]</code>となっている。</p>\n<p>次に、根ノードに対して２という値を持つ左の子ノードを引数に取った<code class=\"language-text\">helper</code>関数が呼び出されるのだが、この関数の再帰構造は、葉ノードにいきつくまでは終わらない。なぜなら、この関数の終了条件（基底部）は、引数として受け取ったノードが<code class=\"language-text\">null</code>の場合のみだからだ。</p>\n<p>よって、根ノードに大して右の子ノード（３という値を持つ）に<code class=\"language-text\">helper</code>関数が実行される段階では、<code class=\"language-text\">ans</code>配列の中身は<code class=\"language-text\">[[1], [2], [4, 5]]</code>となっていることから、このアルゴリズムは深さ優先探索であることがわかる。</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token operator\">**</span><span class=\"token operator\">*</span> 省略 <span class=\"token operator\">**</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">levelOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    ans<span class=\"token punctuation\">,</span> index <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>\n    helper<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> ans<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> ans<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> root<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span>\n\n    <span class=\"token keyword\">if</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">></span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        ans<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    ans<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n    helper<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> ans<span class=\"token punctuation\">,</span> index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    helper<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> ans<span class=\"token punctuation\">,</span> index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>levelOrder<span class=\"token punctuation\">(</span>n1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<br/>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/level-order-tree-traversal/\">Level Order Binary Tree Traversal</a></li>\n<li><a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/33731/Python-short-recursive-and-iterative-solutions\">Python short recursive and iterative solutions</a></li>\n</ul>"}}},"contentfulPoem":null},"pageContext":{"slug":"level_order_binary_tree_traversal","topic":"ContentfulTechEdge","prev":{"slug":"why-i-prefer-to-call-myself-developer","title":"私がエンジニアではなくディベロッパーを名乗る理由","publishedDate":"2021-05-08T23:14+09:00"},"next":{"slug":"gatsby-seo","title":"【Gatsby】検索エンジン最適化(SEO)対策\b方法","publishedDate":"2021-05-03T05:41+09:00"}}},"staticQueryHashes":["1271460761","2463962953","3000541721"]}